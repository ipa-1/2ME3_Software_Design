\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{url}

\oddsidemargin -10mm
\evensidemargin -10mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{Assignment 3, Part 1, Specification}
\author{SFWR ENG 2AA4}

\begin {document}

\maketitle
This Module Interface Specification (MIS) document contains modules, types and
methods for implementing the state of a game of Conway's Game of Life. The game involves a grid of size N x N, of cells that can be ``ALIVE'' or ``DEAD''. The player can set the start state of the game through a txt file that will be read by the program. The program will then construct the game according to the txt file and display the changes from one game state to the next game state.


\newpage

\section* {Board Types Module}

\subsection*{Module}

BoardTypes

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Constants}
SIZE = 4

\subsubsection* {Exported Types}
cellT = \{ALIVE, DEAD\} 

\subsubsection* {Exported Access Programs}

None

\subsection* {Semantics}

\subsubsection* {State Variables}

None

\subsubsection* {State Invariant}

None

\newpage

\section* {Game Board ADT Module}

\subsection*{Template Module}

BoardT

\subsection* {Uses}

\noindent BoardTypes

\subsection* {Syntax}



\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new BoardT  & $s: \mbox{string}$ & BoardT & \\
\hline
read & $s: \mbox{string}$ & & invalid\_argument\\
\hline
write & $s: \mbox{string}$ & & \\
\hline
getRows &  & $\mathbb{N}$ &\\
\hline
getColumns &  & $\mathbb{N}$ & \\
\hline
nextState &  & BoardT &\\
\hline
getCell& $\mathbb{N}$, $\mathbb{N}$ & cellT &invalid\_argument \\
\hline

\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$B$: seq of (seq of T) \textit{\# Gameboard}\\
$rows$: int \textit{\# Number of rows in gameboard}\\
$columns$: int \textit{\# Number of columns in gameboard}\\

\subsubsection* {State Invariant}

\subsubsection* {Assumptions \& Design Decisions}

\begin{itemize}

\item The BoardT constructor is called before any other access
  routine is called on that instance. Once a BoardT has been created, the
  constructor will not be called on it again.

\item The input file will match the given specification

\item For better scalability, this module is specified as an Abstract Data Type
  (ADT) instead of an Abstract Object. This would allow multiple games to be
  created and tracked at once by a client.

\end{itemize}

\subsubsection* {Access Routine Semantics}

\noindent BoardT($\mathit{s}$):
\begin{itemize}
\item transition: 
$B := \text{read}(s) $

\item exception: $ none$
\end{itemize}

\noindent read($s$):

\begin{itemize}
\item transition: read data from the file  associated with the string s.
  The data in the text file will be used to initiate the gameboard state variables $B$, $rows$ and $columns$, where $rows$ is the number of lines in the file, $columns$ is the number of characters on each line in the file, and $B$ holds the CellT at a particular row and column.

  The text file has the following format, where `` `` stand for a CellT with a value of DEAD  and ``o'' stands for CellT with a value of ALIVE. All characters in the file will either be `` `` or  ``o''. lines are separated by a carriage return.  There can be any finite number of lines in the file with finite number of characters on each line as long as the length of each line in the file is the same for every line.  If the length of each line in the file is not the same for the whole file, there is an invalid\_argument exception

\item exception: invalid\_argument
\end{itemize}

\noindent write($s$):

\begin{itemize}
\item transition: write gameboard state to the file  associated with the string s.


  The text file has the following format, where `` `` will be used for cellT with a value of DEAD and ``o'' will be used for cellT with a value of ALIVE. lines are separated by a carriage return. Each line will represent a seq in $B$. Each character in the line will be a representation of the CellT values at that seq and position in the seq


\item exception: none
\end{itemize}


\noindent getRows():
\begin{itemize}
\item output: $out := rows$
\item exception: none
\end{itemize}

\noindent getColumns():
\begin{itemize}
\item output: $out := columns$
\item exception: none
\end{itemize}

\noindent getCell($n_0,n_1$):
\begin{itemize}
\item output: $out := B[n_0][n_1]$
\item exception: $exc := (\lnot \text{isValidCell}(n_0,n_1) ) \Rightarrow \text{invalid\_argument})$

\end{itemize}

\noindent nextState():
\begin{itemize}
\item output: $out := new BoardT(s, rows, columns) \text{ such that } (\forall\, i \in [0..rows-1] : (\forall\, j \in [0..columns-1] : survives(i,j) \Rightarrow s[i][j] = ALIVE \wedge  \neg survives(i,j) \Rightarrow s[i][j] = DEAD) ) $
\item exception: none
\end{itemize}



\subsection*{Local Functions}

\noindent BoardT: $ \text{(seq of seq of CellT)} \times \mathbb{N} \times \mathbb{N} \rightarrow BoardT$\\
\noindent BoardT($\mathit{s,r,c}$)
 
$ \equiv B_2 \text{ such that }  (B_2.getRows() = r \wedge B_2.getColumns = c \wedge  (\forall\, i \in [0..r - 1] : (\forall\, j \in [0..c - 1] : B_2[i][j] = s[i][j]) )
$\\


\noindent isValidCell: $\mathbb{N}  \times \mathbb{N} \rightarrow \mathbb{B} $ \\ 
\noindent isValidCell($n_0,n_1$)  $ \equiv (n_0 < 0 \lor n_0 \ge rows \lor n_1 < 0 \lor n_1 \ge columns) \Rightarrow \text{false}$ \\ 


  
\noindent neighbourCount: $\mathbb{N}  \times \mathbb{N} \rightarrow \mathbb{N}$ \\ 
\noindent neighbourCount($ n_0, n_1$) $\equiv +(\forall i,j: \mathbb{N} | i \in (n_0-1, n_0+1) \wedge
 j\in (n_1-1, n_1+1) \wedge isValidCell(i,j) \wedge (getCell(i,j)) = ALIVE : 1)$ \\


  

 \noindent survives:  $\mathbb{N}  \times \mathbb{N} \rightarrow \mathbb{B}$ \\ 
\noindent survives ($n_0, n_1$) $\equiv$\\



\begin{tabular}{|p{4cm}|p{7cm}|p{4.5cm}|}
\hhline{|-|-|-|}
$B[n_0][n_1] =  \mbox{DEAD}$ & $neighbourCount(n_0,n_1) = 3$ & True  \\
\hhline{|~|-|-|}
 & $neighbourCount(n_0,n_1) \ne 3$ & False\\
\hhline{|-|-|-|}
$B[n_0][n_1] =  \mbox{ALIVE}$ & $neighbourCount(n_0,n_1)= 3 
\lor neighbourCount(n_0,n_1) = 2 $ & True\\
\hhline{|~|-|-|}
&$neighbourCount(n_0,n_1) \neq 3 
\wedge neighbourCount(n_0,n_1) \neq 2 $ & False\\
\hhline{|-|-|-|}
\end{tabular}\\\\

\newpage

\section* {View Module}

\subsection* {Module}

View

\subsection* {Uses}

BoardTypes
GameBoard

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new View &  & View & ~\\
\hline
print & $s: \mbox{BoardT}$ & ~ & ~\\
\hline

\end{tabular}

\subsection* {Semantics}

\subsubsection* {Environment Variables}

\subsubsection* {State Variables}

None

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

The input file will match the given specification.

\subsubsection* {Access Routine Semantics}

\noindent View($s$)
\begin{itemize}
\item Constructor for view

\item exception: none
\end{itemize}

\noindent print($s$)
\begin{itemize}
\item displays the state of the gameboard using text-based ASCII graphics. Dead cells will be represented using `` `` and live cells will be represented using the ``o'' character.
The number of rows and columns depends on the row and column state variables from the gameboard

  \begin{equation}
    \begin{array}{cccc}
      o & o & o & ... \\
      o & o & o & ... \\
      o & o & o & ... \\
      ... & ... & ... & ...\\

    \end{array}
  \end{equation}

\item exception: none
\end{itemize}

\newpage

\section*{Critique of Design}

The interface for the modules has rigour and formality. It uses language from discrete math, which has predefined symbols formal syntax, and precise semantics, removing all ambiguity. As well, arguments are checked to see if they are valid, and if not, an exception is called. Modules exercise a proper amount of separation of concerns, with high cohesion and low coupling. All modules are components of a game, so they are closely related. However, modules only call upon each other when necessary. For example, the StackT object does not call upon any other modules , but only provides the necessary functions for itself. The StackT module exhibits generality, as the T value can be of any type. As a result, StackT can be used to represent stacks of other types. Each function only performs one task, so it is clear how each function could be, or will be used. For example, there is a function ``is\_valid\_tab\_mv,'' which checks to make sure the cardT values are correct, and then a ``is\_valid\_pos'' function which checks to make sure the arguments are valid, and then a ``tab\_mv'' function which actually moves the values. \\

 A possible improvement would be making the ``valid\_tab\_tab'' and other valid functions more general, so that the functions could be reused for other types of solitare . Another related improvement would be the sizes for the tableau and foundation could be a exported constant, so that the number of tableaus and foundation could be changed. Possible considerations would be limiting the size, or setting a constant for a maximum size of the stack of tableaus, as when the game is actually implemented, the tableau will show an image of the cards, and the number of cards in a tableau stack shouldn't be able to extend out of the game window. This will also limit ways the user could use the applications, and prevent possible bugs or errors

\wss{Write a critique of the interface for the modules in this project.  Is there
anything missing?  Is there anything you would consider changing?  Why?}\\

\end {document}